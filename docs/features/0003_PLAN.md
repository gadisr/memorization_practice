# Feature 0003: PostgreSQL Persistence & Firebase Gmail Authentication

## Brief Context

Add PostgreSQL as the persistent data layer to replace localStorage, and implement Gmail login via Firebase Authentication. This enables multi-device access, secure user authentication, cloud data persistence, and user-specific session tracking. Users will authenticate with their Gmail account, and all training sessions (regular pairs, notation drills) will be stored in PostgreSQL associated with their user account.

---

## Phase 1: Data Layer & Database Schema

### 1.1 Database Schema Design

**Migration File:** `backend/alembic/versions/001_initial_schema.py`

**Users Table:**
```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    firebase_uid VARCHAR(128) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    display_name VARCHAR(255),
    profile_picture_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE
);

CREATE INDEX idx_users_firebase_uid ON users(firebase_uid);
CREATE INDEX idx_users_email ON users(email);
```

**Sessions Table:**
```sql
CREATE TABLE sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    session_date TIMESTAMP WITH TIME ZONE NOT NULL,
    drill_type VARCHAR(50) NOT NULL,
    pair_count INTEGER NOT NULL,
    pairs JSONB NOT NULL,
    timings JSONB NOT NULL,
    average_time DECIMAL(10, 3) NOT NULL,
    recall_accuracy DECIMAL(5, 2) NOT NULL,
    vividness INTEGER,
    flow INTEGER,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_date ON sessions(session_date DESC);
CREATE INDEX idx_sessions_drill_type ON sessions(drill_type);
CREATE INDEX idx_sessions_user_date ON sessions(user_id, session_date DESC);
```

**Notation Sessions Table:**
```sql
CREATE TABLE notation_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    session_date TIMESTAMP WITH TIME ZONE NOT NULL,
    drill_type VARCHAR(50) NOT NULL,
    attempts JSONB NOT NULL,
    total_pieces INTEGER NOT NULL,
    correct_count INTEGER NOT NULL,
    accuracy DECIMAL(5, 2) NOT NULL,
    average_time DECIMAL(10, 3) NOT NULL,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_notation_sessions_user_id ON notation_sessions(user_id);
CREATE INDEX idx_notation_sessions_date ON notation_sessions(session_date DESC);
CREATE INDEX idx_notation_sessions_drill_type ON notation_sessions(drill_type);
```

### 1.2 Backend Type Definitions

**File:** `backend/src/models/user.py` (new file)
```python
from sqlalchemy import Column, String, DateTime, Boolean
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import uuid

class User(Base):
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    firebase_uid = Column(String(128), unique=True, nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    display_name = Column(String(255))
    profile_picture_url = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    last_login = Column(DateTime(timezone=True))
    is_active = Column(Boolean, default=True)
```

**File:** `backend/src/models/session.py` (new file)
```python
from sqlalchemy import Column, String, Integer, DECIMAL, DateTime, Text, ForeignKey
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.sql import func
import uuid

class Session(Base):
    __tablename__ = "sessions"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    session_date = Column(DateTime(timezone=True), nullable=False)
    drill_type = Column(String(50), nullable=False)
    pair_count = Column(Integer, nullable=False)
    pairs = Column(JSONB, nullable=False)
    timings = Column(JSONB, nullable=False)
    average_time = Column(DECIMAL(10, 3), nullable=False)
    recall_accuracy = Column(DECIMAL(5, 2), nullable=False)
    vividness = Column(Integer)
    flow = Column(Integer)
    notes = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class NotationSession(Base):
    __tablename__ = "notation_sessions"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    session_date = Column(DateTime(timezone=True), nullable=False)
    drill_type = Column(String(50), nullable=False)
    attempts = Column(JSONB, nullable=False)
    total_pieces = Column(Integer, nullable=False)
    correct_count = Column(Integer, nullable=False)
    accuracy = Column(DECIMAL(5, 2), nullable=False)
    average_time = Column(DECIMAL(10, 3), nullable=False)
    notes = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
```

### 1.3 Pydantic Schemas

**File:** `backend/src/schemas/user.py` (new file)
```python
from pydantic import BaseModel, EmailStr
from datetime import datetime
from uuid import UUID
from typing import Optional

class UserCreate(BaseModel):
    firebase_uid: str
    email: EmailStr
    display_name: Optional[str] = None
    profile_picture_url: Optional[str] = None

class UserUpdate(BaseModel):
    display_name: Optional[str] = None
    profile_picture_url: Optional[str] = None

class UserResponse(BaseModel):
    id: UUID
    firebase_uid: str
    email: str
    display_name: Optional[str]
    profile_picture_url: Optional[str]
    created_at: datetime
    last_login: Optional[datetime]
    
    class Config:
        from_attributes = True
```

**File:** `backend/src/schemas/session.py` (new file)
```python
from pydantic import BaseModel, Field
from datetime import datetime
from uuid import UUID
from typing import List, Optional, Dict, Any
from decimal import Decimal

class SessionCreate(BaseModel):
    session_date: datetime
    drill_type: str
    pair_count: int
    pairs: List[Dict[str, Any]]
    timings: List[float]
    average_time: Decimal
    recall_accuracy: Decimal
    vividness: Optional[int] = None
    flow: Optional[int] = None
    notes: Optional[str] = None

class SessionResponse(BaseModel):
    id: UUID
    user_id: UUID
    session_date: datetime
    drill_type: str
    pair_count: int
    pairs: List[Dict[str, Any]]
    timings: List[float]
    average_time: Decimal
    recall_accuracy: Decimal
    vividness: Optional[int]
    flow: Optional[int]
    notes: Optional[str]
    created_at: datetime
    
    class Config:
        from_attributes = True

class NotationSessionCreate(BaseModel):
    session_date: datetime
    drill_type: str
    attempts: List[Dict[str, Any]]
    total_pieces: int
    correct_count: int
    accuracy: Decimal
    average_time: Decimal
    notes: Optional[str] = None

class NotationSessionResponse(BaseModel):
    id: UUID
    user_id: UUID
    session_date: datetime
    drill_type: str
    attempts: List[Dict[str, Any]]
    total_pieces: int
    correct_count: int
    accuracy: Decimal
    average_time: Decimal
    notes: Optional[str]
    created_at: datetime
    
    class Config:
        from_attributes = True
```

### 1.4 Database Configuration

**File:** `backend/src/core/config.py` (new file)
```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # Database
    DATABASE_URL: str
    DB_ECHO: bool = False
    
    # Firebase
    FIREBASE_PROJECT_ID: str
    FIREBASE_CREDENTIALS_PATH: Optional[str] = None
    
    # API
    API_V1_PREFIX: str = "/api/v1"
    PROJECT_NAME: str = "BLD Memory Trainer API"
    
    # CORS
    ALLOWED_ORIGINS: list[str] = ["http://localhost:8000", "http://localhost:3000"]
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

**File:** `backend/src/core/database.py` (new file)
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from .config import settings

engine = create_engine(settings.DATABASE_URL, echo=settings.DB_ECHO)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

---

## Phase 2A: Authentication Layer

### 2.1 Firebase Admin SDK Setup

**File:** `backend/src/core/firebase.py` (new file)
```python
import firebase_admin
from firebase_admin import credentials, auth
from .config import settings

def initialize_firebase() -> None:
    """Initialize Firebase Admin SDK"""
    if settings.FIREBASE_CREDENTIALS_PATH:
        cred = credentials.Certificate(settings.FIREBASE_CREDENTIALS_PATH)
    else:
        # Use default credentials in production
        cred = credentials.ApplicationDefault()
    
    firebase_admin.initialize_app(cred, {
        'projectId': settings.FIREBASE_PROJECT_ID,
    })

async def verify_firebase_token(id_token: str) -> dict:
    """Verify Firebase ID token and return decoded claims"""
    try:
        decoded_token = auth.verify_id_token(id_token)
        return decoded_token
    except Exception as e:
        raise ValueError(f"Invalid token: {str(e)}")
```

### 2.2 Authentication Middleware

**File:** `backend/src/core/auth.py` (new file)
```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from .firebase import verify_firebase_token
from .database import get_db
from ..models.user import User
from typing import Optional

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """Extract and validate Firebase token, return current user"""
    try:
        # Verify Firebase token
        token = credentials.credentials
        decoded_token = await verify_firebase_token(token)
        firebase_uid = decoded_token['uid']
        
        # Get or create user
        user = db.query(User).filter(User.firebase_uid == firebase_uid).first()
        
        if not user:
            # Create new user from Firebase claims
            user = User(
                firebase_uid=firebase_uid,
                email=decoded_token.get('email'),
                display_name=decoded_token.get('name'),
                profile_picture_url=decoded_token.get('picture')
            )
            db.add(user)
            db.commit()
            db.refresh(user)
        
        # Update last login
        from datetime import datetime
        user.last_login = datetime.utcnow()
        db.commit()
        
        if not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User account is inactive"
            )
        
        return user
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )
```

### 2.3 User Repository

**File:** `backend/src/repositories/user_repository.py` (new file)
```python
from sqlalchemy.orm import Session
from typing import Optional
from uuid import UUID
from ..models.user import User
from ..schemas.user import UserCreate, UserUpdate

def get_user_by_id(db: Session, user_id: UUID) -> Optional[User]:
    return db.query(User).filter(User.id == user_id).first()

def get_user_by_firebase_uid(db: Session, firebase_uid: str) -> Optional[User]:
    return db.query(User).filter(User.firebase_uid == firebase_uid).first()

def get_user_by_email(db: Session, email: str) -> Optional[User]:
    return db.query(User).filter(User.email == email).first()

def create_user(db: Session, user_data: UserCreate) -> User:
    user = User(**user_data.model_dump())
    db.add(user)
    db.commit()
    db.refresh(user)
    return user

def update_user(db: Session, user_id: UUID, user_data: UserUpdate) -> Optional[User]:
    user = get_user_by_id(db, user_id)
    if user:
        for key, value in user_data.model_dump(exclude_unset=True).items():
            setattr(user, key, value)
        db.commit()
        db.refresh(user)
    return user
```

---

## Phase 2B: API Endpoints

### 2.4 User Routes

**File:** `backend/src/api/routes/users.py` (new file)
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List
from ...core.auth import get_current_user
from ...core.database import get_db
from ...models.user import User
from ...schemas.user import UserResponse, UserUpdate
from ...repositories import user_repository

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/me", response_model=UserResponse)
async def get_current_user_profile(
    current_user: User = Depends(get_current_user)
) -> UserResponse:
    """Get current authenticated user profile"""
    return current_user

@router.put("/me", response_model=UserResponse)
async def update_current_user_profile(
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> UserResponse:
    """Update current user profile"""
    updated_user = user_repository.update_user(db, current_user.id, user_update)
    return updated_user
```

### 2.5 Session Routes

**File:** `backend/src/api/routes/sessions.py` (new file)
```python
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
from uuid import UUID
from ...core.auth import get_current_user
from ...core.database import get_db
from ...models.user import User
from ...schemas.session import SessionCreate, SessionResponse
from ...repositories import session_repository

router = APIRouter(prefix="/sessions", tags=["sessions"])

@router.post("/", response_model=SessionResponse, status_code=status.HTTP_201_CREATED)
async def create_session(
    session_data: SessionCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> SessionResponse:
    """Create a new training session"""
    session = session_repository.create_session(db, current_user.id, session_data)
    return session

@router.get("/", response_model=List[SessionResponse])
async def get_user_sessions(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=500),
    drill_type: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> List[SessionResponse]:
    """Get all sessions for current user with optional filters"""
    sessions = session_repository.get_user_sessions(
        db, 
        current_user.id, 
        skip=skip, 
        limit=limit,
        drill_type=drill_type,
        start_date=start_date,
        end_date=end_date
    )
    return sessions

@router.get("/{session_id}", response_model=SessionResponse)
async def get_session(
    session_id: UUID,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> SessionResponse:
    """Get specific session by ID"""
    session = session_repository.get_session_by_id(db, session_id)
    
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    if session.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to access this session")
    
    return session

@router.delete("/{session_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_session(
    session_id: UUID,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Delete a session"""
    session = session_repository.get_session_by_id(db, session_id)
    
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    if session.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="Not authorized to delete this session")
    
    session_repository.delete_session(db, session_id)
```

### 2.6 Notation Session Routes

**File:** `backend/src/api/routes/notation_sessions.py` (new file)
```python
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
from uuid import UUID
from ...core.auth import get_current_user
from ...core.database import get_db
from ...models.user import User
from ...schemas.session import NotationSessionCreate, NotationSessionResponse
from ...repositories import notation_session_repository

router = APIRouter(prefix="/notation-sessions", tags=["notation-sessions"])

@router.post("/", response_model=NotationSessionResponse, status_code=status.HTTP_201_CREATED)
async def create_notation_session(
    session_data: NotationSessionCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> NotationSessionResponse:
    """Create a new notation training session"""
    session = notation_session_repository.create_notation_session(
        db, current_user.id, session_data
    )
    return session

@router.get("/", response_model=List[NotationSessionResponse])
async def get_user_notation_sessions(
    skip: int = Query(0, ge=0),
    limit: int = Query(100, ge=1, le=500),
    drill_type: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> List[NotationSessionResponse]:
    """Get all notation sessions for current user"""
    sessions = notation_session_repository.get_user_notation_sessions(
        db, current_user.id, skip=skip, limit=limit, drill_type=drill_type
    )
    return sessions
```

### 2.7 Session Repository

**File:** `backend/src/repositories/session_repository.py` (new file)
```python
from sqlalchemy.orm import Session
from sqlalchemy import and_
from typing import List, Optional
from datetime import datetime
from uuid import UUID
from ..models.session import Session as SessionModel
from ..schemas.session import SessionCreate

def create_session(db: Session, user_id: UUID, session_data: SessionCreate) -> SessionModel:
    session = SessionModel(
        user_id=user_id,
        **session_data.model_dump()
    )
    db.add(session)
    db.commit()
    db.refresh(session)
    return session

def get_session_by_id(db: Session, session_id: UUID) -> Optional[SessionModel]:
    return db.query(SessionModel).filter(SessionModel.id == session_id).first()

def get_user_sessions(
    db: Session,
    user_id: UUID,
    skip: int = 0,
    limit: int = 100,
    drill_type: Optional[str] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None
) -> List[SessionModel]:
    query = db.query(SessionModel).filter(SessionModel.user_id == user_id)
    
    if drill_type:
        query = query.filter(SessionModel.drill_type == drill_type)
    
    if start_date:
        query = query.filter(SessionModel.session_date >= start_date)
    
    if end_date:
        query = query.filter(SessionModel.session_date <= end_date)
    
    return query.order_by(SessionModel.session_date.desc()).offset(skip).limit(limit).all()

def delete_session(db: Session, session_id: UUID) -> None:
    session = get_session_by_id(db, session_id)
    if session:
        db.delete(session)
        db.commit()
```

### 2.8 FastAPI Main Application

**File:** `backend/src/main.py` (new file)
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
from .core.config import settings
from .core.firebase import initialize_firebase
from .api.routes import users, sessions, notation_sessions

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    initialize_firebase()
    yield
    # Shutdown
    pass

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_PREFIX}/openapi.json",
    lifespan=lifespan
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(users.router, prefix=settings.API_V1_PREFIX)
app.include_router(sessions.router, prefix=settings.API_V1_PREFIX)
app.include_router(notation_sessions.router, prefix=settings.API_V1_PREFIX)

@app.get("/health")
async def health_check():
    return {"status": "healthy"}
```

---

## Phase 3: Frontend Integration

### 3.1 Firebase Client SDK Setup

**File:** `src/config/firebase-config.ts` (new file)
```typescript
import { initializeApp } from 'firebase/app';
import { getAuth, GoogleAuthProvider } from 'firebase/auth';

const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID
};

const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const googleProvider = new GoogleAuthProvider();
```

### 3.2 Authentication Service

**File:** `src/services/auth-service.ts` (new file)
```typescript
import { 
  signInWithPopup, 
  signOut, 
  onAuthStateChanged, 
  User as FirebaseUser 
} from 'firebase/auth';
import { auth, googleProvider } from '../config/firebase-config.js';

export interface AuthState {
  user: FirebaseUser | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
}

let authState: AuthState = {
  user: null,
  token: null,
  isAuthenticated: false,
  isLoading: true
};

const authListeners: ((state: AuthState) => void)[] = [];

export function subscribeToAuthState(callback: (state: AuthState) => void): () => void {
  authListeners.push(callback);
  callback(authState);
  return () => {
    const index = authListeners.indexOf(callback);
    if (index > -1) authListeners.splice(index, 1);
  };
}

function notifyAuthListeners(): void {
  authListeners.forEach(listener => listener(authState));
}

export async function signInWithGoogle(): Promise<FirebaseUser> {
  try {
    const result = await signInWithPopup(auth, googleProvider);
    return result.user;
  } catch (error) {
    console.error('Google sign-in error:', error);
    throw error;
  }
}

export async function logOut(): Promise<void> {
  try {
    await signOut(auth);
  } catch (error) {
    console.error('Sign-out error:', error);
    throw error;
  }
}

export async function getAuthToken(): Promise<string | null> {
  if (auth.currentUser) {
    return await auth.currentUser.getIdToken();
  }
  return null;
}

export function getCurrentUser(): FirebaseUser | null {
  return auth.currentUser;
}

export function getAuthState(): AuthState {
  return authState;
}

// Initialize auth state listener
onAuthStateChanged(auth, async (user) => {
  if (user) {
    const token = await user.getIdToken();
    authState = {
      user,
      token,
      isAuthenticated: true,
      isLoading: false
    };
  } else {
    authState = {
      user: null,
      token: null,
      isAuthenticated: false,
      isLoading: false
    };
  }
  notifyAuthListeners();
});
```

### 3.3 API Client Service

**File:** `src/services/api-client.ts` (new file)
```typescript
import { getAuthToken } from './auth-service.js';
import { SessionData, NotationSessionData } from '../types.js';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api/v1';

async function getAuthHeaders(): Promise<HeadersInit> {
  const token = await getAuthToken();
  return {
    'Content-Type': 'application/json',
    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
  };
}

export async function getCurrentUserProfile(): Promise<any> {
  const headers = await getAuthHeaders();
  const response = await fetch(`${API_BASE_URL}/users/me`, { headers });
  
  if (!response.ok) throw new Error('Failed to fetch user profile');
  
  return response.json();
}

export async function createSession(sessionData: SessionData): Promise<SessionData> {
  const headers = await getAuthHeaders();
  const response = await fetch(`${API_BASE_URL}/sessions`, {
    method: 'POST',
    headers,
    body: JSON.stringify(sessionData)
  });
  
  if (!response.ok) throw new Error('Failed to create session');
  
  return response.json();
}

export async function getUserSessions(
  skip: number = 0,
  limit: number = 100,
  drillType?: string
): Promise<SessionData[]> {
  const headers = await getAuthHeaders();
  const params = new URLSearchParams({
    skip: skip.toString(),
    limit: limit.toString(),
    ...(drillType ? { drill_type: drillType } : {})
  });
  
  const response = await fetch(`${API_BASE_URL}/sessions?${params}`, { headers });
  
  if (!response.ok) throw new Error('Failed to fetch sessions');
  
  return response.json();
}

export async function createNotationSession(
  sessionData: NotationSessionData
): Promise<NotationSessionData> {
  const headers = await getAuthHeaders();
  const response = await fetch(`${API_BASE_URL}/notation-sessions`, {
    method: 'POST',
    headers,
    body: JSON.stringify(sessionData)
  });
  
  if (!response.ok) throw new Error('Failed to create notation session');
  
  return response.json();
}

export async function getUserNotationSessions(
  skip: number = 0,
  limit: number = 100,
  drillType?: string
): Promise<NotationSessionData[]> {
  const headers = await getAuthHeaders();
  const params = new URLSearchParams({
    skip: skip.toString(),
    limit: limit.toString(),
    ...(drillType ? { drill_type: drillType } : {})
  });
  
  const response = await fetch(`${API_BASE_URL}/notation-sessions?${params}`, { headers });
  
  if (!response.ok) throw new Error('Failed to fetch notation sessions');
  
  return response.json();
}
```

### 3.4 Storage Adapter Layer

**File:** `src/storage/storage-adapter.ts` (new file)
```typescript
import { SessionData, NotationSessionData } from '../types.js';
import { getAuthState } from '../services/auth-service.js';
import * as apiClient from '../services/api-client.js';
import * as localSessionStorage from './session-storage.js';
import * as localNotationStorage from './notation-storage.js';

/**
 * Unified storage adapter that uses API when authenticated, localStorage when not
 */

export async function saveSession(session: SessionData): Promise<void> {
  const { isAuthenticated } = getAuthState();
  
  if (isAuthenticated) {
    await apiClient.createSession(session);
  } else {
    localSessionStorage.saveSession(session);
  }
}

export async function getAllSessions(): Promise<SessionData[]> {
  const { isAuthenticated } = getAuthState();
  
  if (isAuthenticated) {
    return await apiClient.getUserSessions();
  } else {
    return localSessionStorage.getAllSessions();
  }
}

export async function saveNotationSession(session: NotationSessionData): Promise<void> {
  const { isAuthenticated } = getAuthState();
  
  if (isAuthenticated) {
    await apiClient.createNotationSession(session);
  } else {
    localNotationStorage.saveNotationSession(session);
  }
}

export async function getAllNotationSessions(): Promise<NotationSessionData[]> {
  const { isAuthenticated } = getAuthState();
  
  if (isAuthenticated) {
    return await apiClient.getUserNotationSessions();
  } else {
    return localNotationStorage.getAllNotationSessions();
  }
}

/**
 * Migrate localStorage data to API when user authenticates
 */
export async function migrateLocalDataToAPI(): Promise<void> {
  const localSessions = localSessionStorage.getAllSessions();
  const localNotationSessions = localNotationStorage.getAllNotationSessions();
  
  // Migrate regular sessions
  for (const session of localSessions) {
    try {
      await apiClient.createSession(session);
    } catch (error) {
      console.error('Failed to migrate session:', session.id, error);
    }
  }
  
  // Migrate notation sessions
  for (const session of localNotationSessions) {
    try {
      await apiClient.createNotationSession(session);
    } catch (error) {
      console.error('Failed to migrate notation session:', session.id, error);
    }
  }
  
  // Clear local storage after successful migration
  localSessionStorage.clearAllSessions();
  localNotationStorage.clearAllNotationSessions();
}
```

### 3.5 Authentication UI Components

**File:** `src/ui/auth-ui.ts` (new file)
```typescript
import { signInWithGoogle, logOut, subscribeToAuthState, AuthState } from '../services/auth-service.js';
import { migrateLocalDataToAPI } from '../storage/storage-adapter.js';

export function initializeAuthUI(): void {
  const loginButton = document.getElementById('login-button');
  const logoutButton = document.getElementById('logout-button');
  const userProfile = document.getElementById('user-profile');
  const userEmail = document.getElementById('user-email');
  const userAvatar = document.getElementById('user-avatar');
  
  // Subscribe to auth state changes
  subscribeToAuthState(async (state: AuthState) => {
    if (state.isLoading) {
      // Show loading state
      return;
    }
    
    if (state.isAuthenticated && state.user) {
      // User is logged in
      loginButton?.classList.add('hidden');
      logoutButton?.classList.remove('hidden');
      userProfile?.classList.remove('hidden');
      
      if (userEmail) userEmail.textContent = state.user.email || '';
      if (userAvatar && state.user.photoURL) {
        (userAvatar as HTMLImageElement).src = state.user.photoURL;
      }
      
      // Migrate local data if any exists
      await migrateLocalDataToAPI();
      
      // Refresh dashboard with API data
      await refreshDashboard();
    } else {
      // User is logged out
      loginButton?.classList.remove('hidden');
      logoutButton?.classList.add('hidden');
      userProfile?.classList.add('hidden');
    }
  });
  
  // Login button handler
  loginButton?.addEventListener('click', async () => {
    try {
      await signInWithGoogle();
    } catch (error) {
      console.error('Login failed:', error);
      alert('Login failed. Please try again.');
    }
  });
  
  // Logout button handler
  logoutButton?.addEventListener('click', async () => {
    try {
      await logOut();
    } catch (error) {
      console.error('Logout failed:', error);
    }
  });
}

async function refreshDashboard(): Promise<void> {
  // Reload dashboard data from API
  // This will be implemented in existing dashboard code
  const event = new CustomEvent('auth-state-changed');
  window.dispatchEvent(event);
}
```

### 3.6 HTML Updates

**File:** `public/index.html` (extend existing)
```html
<!-- Add to header -->
<div id="auth-container">
  <button id="login-button" class="btn-primary">
    <img src="https://www.google.com/favicon.ico" alt="Google" width="20" />
    Sign in with Google
  </button>
  
  <div id="user-profile" class="hidden">
    <img id="user-avatar" src="" alt="User" class="avatar" />
    <span id="user-email"></span>
    <button id="logout-button">Sign Out</button>
  </div>
</div>
```

### 3.7 Update Existing Storage Calls

**Files to update:**
- `src/app.ts` - Replace direct storage calls with storage-adapter calls
- `src/ui/dashboard.ts` - Use async storage-adapter methods
- `src/services/session-manager.ts` - Update to use storage-adapter

**Pattern for all files:**
```typescript
// OLD:
import { saveSession } from './storage/session-storage.js';
saveSession(sessionData);

// NEW:
import { saveSession } from './storage/storage-adapter.js';
await saveSession(sessionData);
```

---

## Phase 4: Infrastructure & Deployment

### 4.1 Environment Configuration

**File:** `backend/.env.example` (new file)
```bash
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/bld_trainer

# Firebase
FIREBASE_PROJECT_ID=your-project-id
FIREBASE_CREDENTIALS_PATH=/path/to/firebase-credentials.json

# API
API_V1_PREFIX=/api/v1
PROJECT_NAME=BLD Memory Trainer API

# CORS
ALLOWED_ORIGINS=["http://localhost:8000","http://localhost:3000"]
```

**File:** `.env.example` (frontend, new file)
```bash
VITE_API_BASE_URL=http://localhost:8000/api/v1
VITE_FIREBASE_API_KEY=your-api-key
VITE_FIREBASE_AUTH_DOMAIN=your-project.firebaseapp.com
VITE_FIREBASE_PROJECT_ID=your-project-id
VITE_FIREBASE_STORAGE_BUCKET=your-project.appspot.com
VITE_FIREBASE_MESSAGING_SENDER_ID=your-sender-id
VITE_FIREBASE_APP_ID=your-app-id
```

### 4.2 Docker Configuration

**File:** `docker-compose.yml` (new file)
```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: bld_trainer_db
    environment:
      POSTGRES_USER: bld_user
      POSTGRES_PASSWORD: bld_password
      POSTGRES_DB: bld_trainer
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U bld_user -d bld_trainer"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build: ./backend
    container_name: bld_trainer_api
    environment:
      DATABASE_URL: postgresql://bld_user:bld_password@postgres:5432/bld_trainer
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - ./backend:/app
    command: uvicorn src.main:app --host 0.0.0.0 --port 8000 --reload

volumes:
  postgres_data:
```

**File:** `backend/Dockerfile` (new file)
```dockerfile
FROM python:3.12-slim

WORKDIR /app

# Install poetry
RUN pip install poetry

# Copy dependency files
COPY pyproject.toml poetry.lock ./

# Install dependencies
RUN poetry config virtualenvs.create false \
    && poetry install --no-interaction --no-ansi

# Copy application
COPY . .

# Run migrations and start server
CMD ["sh", "-c", "alembic upgrade head && uvicorn src.main:app --host 0.0.0.0 --port 8000"]
```

### 4.3 Dependencies

**File:** `backend/pyproject.toml` (new file)
```toml
[tool.poetry]
name = "bld-trainer-backend"
version = "0.1.0"
description = "Backend API for BLD Memory Trainer"
authors = ["Your Name <you@example.com>"]

[tool.poetry.dependencies]
python = "^3.12"
fastapi = "^0.109.0"
uvicorn = {extras = ["standard"], version = "^0.27.0"}
sqlalchemy = "^2.0.25"
psycopg2-binary = "^2.9.9"
alembic = "^1.13.1"
pydantic = "^2.5.3"
pydantic-settings = "^2.1.0"
firebase-admin = "^6.4.0"
python-dotenv = "^1.0.0"

[tool.poetry.dev-dependencies]
pytest = "^7.4.4"
pytest-asyncio = "^0.23.3"
black = "^23.12.1"
ruff = "^0.1.11"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"
```

**File:** `backend/alembic.ini` (new file)
```ini
[alembic]
script_location = alembic
prepend_sys_path = .
sqlalchemy.url = postgresql://bld_user:bld_password@localhost:5432/bld_trainer

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
```

**File:** `package.json` (update existing)
```json
{
  "scripts": {
    "build": "tsc",
    "serve": "python3 serve.py",
    "dev": "python3 serve.py",
    "watch": "tsc --watch",
    "docker:up": "docker-compose up -d",
    "docker:down": "docker-compose down",
    "docker:logs": "docker-compose logs -f"
  },
  "dependencies": {
    "firebase": "^10.7.1"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "vite": "^5.0.0"
  }
}
```

---

## Key Algorithms

### Authentication Flow
```
1. User clicks "Sign in with Google"
2. Firebase Auth popup opens
3. User selects Gmail account and authorizes
4. Firebase returns ID token
5. Frontend stores token in memory
6. Frontend sends token in Authorization header for all API requests
7. Backend verifies token with Firebase Admin SDK
8. Backend extracts user info from token
9. Backend checks if user exists in database:
   - If exists: update last_login, return user
   - If new: create user record, return user
10. Return user profile to frontend
```

### Data Migration Flow
```
1. User authenticates for first time
2. Auth state listener detects authentication
3. Trigger migrateLocalDataToAPI():
   a. Read all sessions from localStorage
   b. For each session:
      - POST to /api/v1/sessions
      - Log any errors but continue
   c. Read all notation sessions from localStorage
   d. For each notation session:
      - POST to /api/v1/notation-sessions
      - Log any errors but continue
   e. If all migrations successful:
      - Clear localStorage
      - Show success message
4. Refresh dashboard with API data
```

### Storage Adapter Decision Logic
```
function saveSession(session):
  if user is authenticated:
    token = await getAuthToken()
    POST /api/v1/sessions with Authorization header
  else:
    save to localStorage
  
function getAllSessions():
  if user is authenticated:
    token = await getAuthToken()
    GET /api/v1/sessions with Authorization header
    return sessions from API
  else:
    return sessions from localStorage
```

### Token Refresh Flow
```
1. Firebase SDK automatically refreshes tokens
2. getAuthToken() always returns fresh token
3. If token expired, Firebase SDK handles refresh transparently
4. If refresh fails (e.g., user revoked access):
   - Firebase triggers signOut
   - Auth state listener updates UI
   - User must re-authenticate
```

---

## File Structure

```
memorization_practice/
├── backend/                          [NEW]
│   ├── alembic/                      [NEW]
│   │   ├── versions/
│   │   │   └── 001_initial_schema.py
│   │   └── env.py
│   ├── src/                          [NEW]
│   │   ├── api/
│   │   │   └── routes/
│   │   │       ├── users.py
│   │   │       ├── sessions.py
│   │   │       └── notation_sessions.py
│   │   ├── core/
│   │   │   ├── config.py
│   │   │   ├── database.py
│   │   │   ├── firebase.py
│   │   │   └── auth.py
│   │   ├── models/
│   │   │   ├── user.py
│   │   │   └── session.py
│   │   ├── schemas/
│   │   │   ├── user.py
│   │   │   └── session.py
│   │   ├── repositories/
│   │   │   ├── user_repository.py
│   │   │   ├── session_repository.py
│   │   │   └── notation_session_repository.py
│   │   └── main.py
│   ├── Dockerfile                    [NEW]
│   ├── pyproject.toml                [NEW]
│   ├── poetry.lock                   [NEW]
│   ├── alembic.ini                   [NEW]
│   └── .env.example                  [NEW]
├── src/
│   ├── config/
│   │   └── firebase-config.ts        [NEW]
│   ├── services/
│   │   ├── auth-service.ts           [NEW]
│   │   └── api-client.ts             [NEW]
│   ├── storage/
│   │   ├── storage-adapter.ts        [NEW]
│   │   ├── session-storage.ts        [EXTEND]
│   │   └── notation-storage.ts       [EXTEND]
│   ├── ui/
│   │   └── auth-ui.ts                [NEW]
│   └── app.ts                        [EXTEND]
├── public/
│   └── index.html                    [EXTEND]
├── docker-compose.yml                [NEW]
├── .env.example                      [NEW]
└── package.json                      [EXTEND]
```

---

## Implementation Notes

1. **Firebase Setup**: Create Firebase project, enable Google authentication, download service account key for backend.

2. **Database Initialization**: Run `docker-compose up -d postgres`, then `alembic upgrade head` to create tables.

3. **CORS Configuration**: Ensure backend allows frontend origin. Update ALLOWED_ORIGINS in .env for production.

4. **Token Security**: ID tokens are sent in Authorization header. Never store tokens in localStorage (XSS risk). Keep in memory only.

5. **Offline Support**: App still works offline using localStorage. Data syncs when user authenticates.

6. **Migration Safety**: Migration preserves localStorage data until API confirms successful upload. Show progress to user.

7. **Error Handling**: 
   - 401 Unauthorized → Sign out user, show login screen
   - 403 Forbidden → Show "Access denied" message
   - 500 Server Error → Fall back to localStorage, show notification

8. **Database Indexing**: Indexes on user_id, session_date for fast queries. JSONB columns for flexible data storage.

9. **API Versioning**: Use /api/v1 prefix to support future API versions without breaking changes.

10. **Testing**: Test both authenticated and unauthenticated flows. Verify migration works correctly.

---

## Validation Checklist

- [ ] PostgreSQL database created and accessible
- [ ] Alembic migrations run successfully
- [ ] Firebase project configured with Google auth
- [ ] Service account key generated for backend
- [ ] Backend .env configured with database URL and Firebase credentials
- [ ] Frontend .env configured with Firebase config and API URL
- [ ] Docker containers running (postgres, backend)
- [ ] Google sign-in popup works
- [ ] User created in database on first login
- [ ] Sessions saved to database when authenticated
- [ ] Sessions saved to localStorage when not authenticated
- [ ] Migration from localStorage to database works
- [ ] Dashboard loads data from API when authenticated
- [ ] Dashboard loads data from localStorage when not authenticated
- [ ] Token refresh handled automatically
- [ ] Sign out clears auth state
- [ ] CORS allows frontend to call backend
- [ ] API endpoints require authentication
- [ ] User can only access their own sessions

---

**Please do [docs/features/0003_PLAN.md]**

